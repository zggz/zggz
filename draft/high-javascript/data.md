---
title: 数据存取
date: 2019-02-01 16:47:12
tags: 性能
categories: javascript
---
##  作用域链
每一个javascript函数都可以表示为一个对象，更确切的说，是Function对象的一个实例，拥有可以编程访问的属性和一系列不能访问的内部属性，其中一个是[[Scope]]。内部属性[[scope]]包含了一个函数被创建作用域中对象的集合，那么这个集合被称为作用域链，它决定了那些能被函数访问。
<!-- more -->
当函数被执行时会创建一个执行环境，每个执行环境都有自己的作用域，用于解析标识符，在函数的执行中每遇到一个变量都会经历一次标识符解析，会持续的在作用域链中去搜索匹配这个对象，正是这个过程影响了性能，正是由于标识符的解析过程，所以出现同名的变量那么第二个会覆盖第一个变量。

### 局部变量
由于全局变量会在最远处，所以最好使用局部变量会更快。
由于很多全局变量比如document等，通过在函数局部声明变量来承载，会提高性能
```js
function test(){
    links = document.getElementByTagName('a')
    document.getElementById('click').onClick = function(){

    }
    // 以上的案例会搜索全局变量document两次
    var dc = document
    links = dc.getElementByTagName('a')
    dc.getElementById('click').onClick = function(){

    }
    // 以上案例智慧搜索一次全局变量document，解析标识符的路径会更短
}
```
### 闭包
由于在闭包存在的情况下，执行环境无法被销毁，也就是说会消耗更多的内存。在使用闭包的情况下会创建一个执行环境与属性[[scope]]中所引用的相同作用域对象一起被初始化；在闭包中用到的标识符，位于作用域链的第一个作用域之后，在频繁的跨作用域访问标识符，会带来性能损耗

## 对象成员
javascript是基于原型。原型是对象的基础；对象通过内部属性\_proto\_绑定其成员变量。当函数或者对象读取或者执行的时候，会在当前实例搜索变量，没有则继续搜索原型对象，可以通过hasOwnProperty、in操作符来判断当前实例是否具有该属性或者方法。正是这个逐级搜索的过程严重的拖慢了访问成员变量的时间

<font color=green>1. 嵌套成员</font>:对象中包含其他对象，例如window.location.href每次遇到点操作符，嵌套成员会导致javascript引擎搜索所有对象成员，嵌套的越深读取速度就越慢，执行location.href总会比window.location.href要快。（在大部分浏览器中点操作和括号表示法没有明显的区别，只有Safari中点操作始终比括号表示法更快）

<font color=green>2. 缓存对象成员</font>:在同一函数中没必要多次读取同一个对象成员。通常来说在函数中需要多次读取一个对象属性，最佳做法是局部变量缓存，降低多次查找带来的开销，特别是在处理嵌套成员的时候。不要再同一函数下多次查找一个对象，除非这个对象值变化了

## 小结
1. 访问字面量和局部变量速度最快，访问数组和对象成员相对会慢
2. 局部变量处于顶端起始位置会比跨作用域访问更快；而全局变量处于作用域末端，访问速度最慢
3. 避免使用with，它会改变执行环境的作用域链；try-catch中的catch也会改变执行环境作用域链，因此需要小心使用
4. 嵌套成员明显影响性能，尽可能少用
5. 通常来说使用缓存变量到函数的局部环境，会改善javascript性能
