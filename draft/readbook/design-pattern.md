---
title: 简单设计模式
date: 2020-10-06 11:47:42
update: 2020-10-08 11:47:42
tags: 设计模式
---

简单学习相关设计模式（大话设计模式），以下是概念描述；具体实例参考

<!--more-->

[实例代码](https://github.com/HUSTER-Qin/yoHe/tree/master/designPattern)

<!-- more -->

### 依赖倒转
* 是面向对象设计的标志，即程序中所有的依赖关系都是终止与抽象类或者看接口
### 迪米特法则
* 如果两个类不必彼此直接通信，那么这两个类就不该发生直接的相互作用。如果其中一个类需要调另一个类的某一个方法的话，可以通过第三者转发这个应用
### 封装
- 业务逻辑和界面逻辑分开，耦合度降低
### 单一职责链原则（SRP）
* 就一个类而言，应该仅有一个使它变化的原因
### 开放封闭原则
* 可以扩展，但不能修改
### 依赖倒转原则
* 抽象不应该依赖细节，细节应该依赖于抽象(针对接口编程，不要对实现编程)
* 高层模块不应该依赖底层模块，两个都应该依赖抽象
* 抽象不应该依赖细节，细节应该依赖抽象[ASD]
### 里氏替换原则
* 子类型必须能够替换它们的父类型[ASD]
### 合成/聚合复用原则
* 尽量使用合成聚合，尽量不要使用类继承

## 设计模式
### 策略模式
* 策略模式指的是定义一系列的算法，并且把它们封装起来，但是策略模式不仅仅只封装算法，我们还可以对用来封装一系列的业务规则，只要这些业务规则目标一致，我们就可以使用策略模式来封装它们
### 装饰模式
* 动态地给一个对象添加一些额外的职责
### 代理模式
* 为其他对象提供一种代理以控制对这个对象的访问
### 外观模式
* 为子系统中的一组接口提供一致的界面，此模式定义一组高层接口，使得子系统更加易于使用
### 建造者模式
* 一个复杂对象的构建与它的表示分离，使得同样的构造过程可以构建不同的表示
### 抽象工厂模式
* 提供一个创建一系列相关或相互依赖对象接口，而无需指定他们具体的类
### 状态模式
* 当一个对像的内在状态改变时允许改变其行为，这个对象看起来是改变了其类
### 组合模式
* 将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性
### 迭代器模式
* 提供一种方法顺序访问对象的各个元素，而又不暴露该对象的内部表示
### 桥接模式
* 将抽象部分与它的实现部分分离，使他们都可以独立地变化
### 命令模式
* 将一个请求封装为一个对象，从而使你可用不同的请求对客服进行参数化，对请求排队或者记录日志，以及支持可撤销的操作
### 职责链模式
* 使多个对象都有机会处理请求,从而避免请求的发送者和接受者这间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，知道有一个对象处理它为止

### 中介者模式
* 用一个对象来封装一系列的对象交互。
###  享元模式
* 运用共享技术有效的支持大量细粒度的对象
### 解释器模式
* 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该该表示解释语言中的句子
